const utils = require("@babel/types/lib/definitions/utils")
const defineType = utils.default
const assertValueType = utils.assertValueType
const syntaxToDatum = require("./syntaxToDatum")

defineType("SymbolLiteral", {
  builder: ["value"],

  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],

  fields: {
    value: {
      validate: assertValueType("string"),
    },

    optional: {
      validate: assertValueType("boolean"),

      optional: true,
    },
  },
})

const {
  arrayExpression,
  objectProperty,
  objectExpression,
  stringLiteral,
  numericLiteral,
  booleanLiteral,
  nullLiteral,
  callExpression,
  identifier,
  isIdentifier,
  memberExpression,
} = require("@babel/types")
const resolve = require("./resolve")

function syntaxQuote(syntax) {
  if (Array.isArray(syntax)) {
    return arrayExpression(syntax.map((arg) => syntaxQuote(arg)))
  }
  switch (typeof syntax) {
    case "object":
      return syntax === null
        ? nullLiteral()
        : objectExpression(
            Object.entries(syntax).map(([key, value]) =>
              objectProperty(identifier(key), syntaxQuote(value))
            )
          )
    case "string":
      return stringLiteral(syntax)
    case "number":
      return numericLiteral(syntax)
    case "boolean":
      return booleanLiteral(syntax)
    case "undefined":
      return identifier("undefined")
    case "symbol":
      return callExpression(
        memberExpression(identifier("Symbol"), identifier("for")),
        [stringLiteral(Symbol.keyFor(syntax))]
      )
  }
}

function syntaxQuasiQuote(form, env) {
  if (form.type !== "ArrayExpression") {
    return syntaxQuote(form, env)
  }
  return syntaxQuote({
    ...form,
    elements: form.elements.map((element) => {
      if (
        element.type === "ArrayExpression" &&
        syntaxToDatum(element.elements[0]) === Symbol.for("syntaxUnquote")
      ) {
        return expand(element.elements[1], env)
      }
      return element
    }),
  })
}

function expand(syntax, env) {
  switch (syntax.type) {
    case "ArrayExpression": {
      const first = expand(syntax.elements[0], env)
      if (isIdentifier(first)) {
        switch (first.name) {
          case "quote":
            return syntax.elements[1]
          case "syntaxQuote":
            return syntaxQuote(syntax.elements[1], env)
          case "syntaxQuasiQuote":
            return syntaxQuasiQuote(syntax.elements[1], env)
          default:
            const resolved = resolve(first.name, env, first.scopes)
            if (resolved && typeof resolved === "function") {
              return expand(resolved(syntax, env), env)
              // TODO: This is how we expand macro returning macros, but there
              // is probably a better way
            }
        }
      }
      if (typeof first === "function") {
        return expand(first(syntax, env), env)
      }
      return callExpression(
        first,
        syntax.elements.slice(1).map((s) => expand(s, env))
      )
    }
    case "SymbolLiteral":
      const key = Symbol.keyFor(syntax.value)
      return resolve(key, env, syntax.scopes) || identifier(key)
    default:
      return syntax
  }
}

module.exports = expand
