const {
  arrayExpression,
  objectProperty,
  objectExpression,
  stringLiteral,
  numericLiteral,
  booleanLiteral,
  nullLiteral,
  callExpression,
  identifier,
  isIdentifier,
  memberExpression,
} = require("@babel/types")
const resolve = require("./resolve")

function expandQuote(syntax) {
  if (Array.isArray(syntax)) {
    return arrayExpression(syntax.map((arg) => syntaxQuote(arg)))
  }
  switch (typeof syntax) {
    case "object":
      return syntax === null
        ? nullLiteral()
        : objectExpression(
            Object.entries(syntax).map(([key, value]) =>
              objectProperty(identifier(key), syntaxQuote(value))
            )
          )
    case "string":
      return stringLiteral(syntax)
    case "number":
      return numericLiteral(syntax)
    case "boolean":
      return booleanLiteral(syntax)
    case "undefined":
      return identifier("undefined")
    case "symbol":
      return callExpression(
        memberExpression(identifier("Symbol"), identifier("for")),
        [stringLiteral(Symbol.keyFor(syntax))]
      )
  }
}

function expand(syntax, env) {
  switch (syntax.type) {
    case "CallExpression": {
      const first = expand(syntax.callee, env)
      if (isIdentifier(first)) {
        switch (first.name) {
          case "quote":
            return expandQuote(syntax.arguments[1], env)
          default:
            const resolved = resolve(first.name, env, first.scopes)
            if (resolved && typeof resolved === "function") {
              return expand(resolved(syntax, env), env)
              // TODO: This is how we expand macro returning macros, but there
              // is probably a better way
            }
        }
      }
      if (typeof first === "function") {
        return expand(first(syntax, env), env)
      }
      return callExpression(first, syntax.arguments.map((s) => expand(s, env)))
    }
    default:
      return syntax
  }
}

module.exports = expand

const read = require("@blisp/reader/read")
const form = read('((. console log) "foo")')
console.log(form)

function nth(form, n) {
  if (Array.isArray(form)) {
    return form[n]
  }
  switch (form.type) {
    case "CallExpression":
      return n === 0 ? form.callee : form.arguments[n - 1]
  }
}

function first(form) {
  return nth(form, 0)
}

function second(form) {
  return nth(form, 1)
}

function third(form) {
  return nth(form, 2)
}

function rest(form) {
  switch (form.type) {
    case "CallExpression":
      return form.arguments
  }
}

const env = {
  ".": [
    (form, env) =>
      memberExpression(expand(second(form), env), expand(third(form), env)),
  ],
}

const expanded = expand(form, env)
console.log(expanded)

const generate = require("@babel/generator").default

const generated = generate(expanded)
console.log(generated)

eval(generated.code)
