const t = require("@babel/types")
const generate = require("@babel/generator").default

const quoted = Symbol("quoted")

class CallExpression extends Array {
  compile() {
    return t.callExpression(
      this[0].compile(),
      this.slice(1).map((param) => param.compile())
    )
  }
}

/**
 *  (get foo 'b)
 *    -> MemberExpression [
 *         Identifier("get"),
 *         Identifier("foo"),
 *         QuotedIdentifier("b")] -> foo.b
 *  (get foo b)
 *    -> MemberExpression [
 *         Identifier("get"),
 *         Identifier("foo"),
 *         Identifier("b")] -> foo[b]

 */
class MemberExpression extends Array {
  compile() {
    return t.memberExpression(
      this[1].compile(),
      Array.isArray(this[2]) ? this[2][0].compile() : this[2].compile(),
      Array.isArray(this[2])
    )
  }
}

class Identifier {
  constructor(id) {
    this.id = id
  }
  valueOf() {
    return Symbol.for(this.id)
  }
  compile() {
    return t.identifier(this.id)
  }
}

class SymbolLiteral extends Symbol {
  compile() {
    return t.newExpression(t.identifier("SymbolLiteral"), [
      t.callExpression(
        t.memberExpression(t.identifier("Symbol"), t.identifier("for")),
        new ArrayExpression(Symbol.keyFor(this.valueOf()))
      ),
    ])
  }
}

class ArrayExpression extends Array {
  compile() {
    return t.arrayExpression(this.map((elem) => elem.compile()))
  }
}

class StringLiteral extends String {
  compile() {
    return t.stringLiteral(this.valueOf())
  }
}

function resolve(id, env) {
  return env[id.valueOf()]
}

function expand(form, env) {
  if (form[quoted]) {
    form[quoted] = false
    return form
  }
  if (form instanceof CallExpression) {
    let first = expand(form[0], env)
    if (first instanceof Identifier) {
      first = resolve(first, env)
    }
    if (typeof first === "function") {
      return first(form, env)
    }
    return form.map((innerForm) => expand(innerForm, env))
  } else if (form instanceof SymbolLiteral) {
    return new Identifier(Symbol.keyFor(form.valueOf()))
  } else if (form instanceof Array) {
    return form.map((element) => expand(element, env))
  }
  return form
}

function compile(form) {
  return form.compile()
}

const env = {
  CallExpression,
  MemberExpression,
  Identifier,
  StringLiteral,
  ArrayLiteral,
  [Symbol.for("get")]: (form, env) =>
    new MemberExpression(
      form[0],
      ...form.slice(1).map((innerForm) => expand(innerForm, env))
    ),
  [Symbol.for("quote")]: (form, env) => {
    form[quoted] = true
    return form[1]
  },
}

class Quote extends Array {
  compile() {}
}

// console["log"]("foo")
const form = new CallExpression(
  new Identifier("quote"),
  new CallExpression(
    new CallExpression(
      new Identifier("get"),
      new Identifier("console"),
      new Identifier("log")
      // [new CallExpression(new Identifier("foo"))]
    ),
    new StringLiteral("Hello World!")
  )
)

function foo() {
  return "log"
}

console.log(form)

const expanded = expand(form, env)
console.log(expanded)

const compiled = compile(expanded)
console.log(compiled)

const generated = generate(compiled)
console.log(generated)

eval(generated.code)

module.exports = compile
