const t = require("@babel/types")
const generate = require("@babel/generator").default

function resolve(form, env) {
  return form && typeof form.valueOf() === "symbol" && env[form.valueOf()]
}

function compile(form, env) {
  if (Array.isArray(form)) {
    const compiler = resolve(form[0], env)
    if (!compiler) {
      console.error(`Not a function got: ${compiler}`)
    }
    return compiler(form, env)
  }
  switch (typeof form.valueOf()) {
    case "symbol":
      return Object.assign(t.identifier(Symbol.keyFor(form.valueOf())), form)
    case "string":
      return Object.assign(t.stringLiteral(form.valueOf()))
    case "number":
      return Object.assign(t.numericLiteral(form.valueOf()))
    case "boolean":
      return Object.assign(t.booleanLiteral(form.valueOf()))
    case "undefined":
      return t.identifier("undfined")
    case "object":
      if (object) {
        throw new Error("Objects not handled yet")
      }
      return t.nullLiteral()
  }
  return form
}

function compileMeta(meta) {
  if (Array.isArray(meta)) {
    return t.arrayExpression(meta.map(compileMeta))
  }
  switch (typeof meta) {
    case "object":
      return meta
        ? t.objectExpression(
            Object.entries(form).map(([key, value]) =>
              t.objectProperty(t.identifier(key), compileMeta(value))
            )
          )
        : t.nullLiteral()
    case "string":
      return t.stringLiteral(meta)
    case "number":
      return t.numericLiteral(meta)
    case "boolean":
      return t.booleanLiteral(meta)
    case "symbol":
      return t.callExpression(
        t.memberExpression(t.identifier("Symbol"), t.identifier("for")),
        [compileMeta(Symbol.keyFor(meta))]
      )
    case "undefined":
      t.identifier("undefined")
  }
}

// (deepEqual (eval (compile '(+ 1 2))) (+ 1 2))
function compileQuote(form, env) {
  if (Array.isArray(form)) {
  }
  switch (typeof form.valueOf()) {
    case "string":
      return t.callExpression(
        t.memberExpression(t.identifier("Object"), t.identifier("assign")),
        [compileMeta(form.valueOf()), compileMeta(form)]
      )
  }
}

/**
 * ((. console log) "foo")
 * (define var (foo "bar"))
 *
 * Object.assign([Object.assign([Object.assign(Symbol.for("."), { loc: { start: .3..})])])
 *
 * { type: "CallExpression", object: { type: "CallExpression", object: { type: "Identifier", name: ".", loc: { ...}}}, arguments: [...]}
 *
 * syntaxToDatum(form) -> [callee, ...arguments]
 * (first form) -> form.callee
 * (first [])  -> form.elements[0]
 *
 * form[0] ->
 *
 * form[0][0]
 *
 * const meta = new WeakMap()
 *
 *
 *
 */

const metaMap = new WeakMap()

function withMeta(form, meta) {
  metaMap.set(form, meta)
}

const form = [Object.assign(Symbol.for("withMeta"), [
  [
    Object.assign(Symbol.for(".")),
    Object.assign(Symbol.for("console")),
    Object.assign(Symbol.for("log")),
  ],
  new String("foo"),
], { ...meta }]

const env = {
  [Symbol.for("call")]: (form, env) =>
    t.callExpression(
      compile(form[1], env),
      form.slice(2).map((subForm) => compile(subForm, env))
    ),
  [Symbol.for(".")]: (form, env) =>
    t.memberExpression(compile(form[1], env), compile(form[2], env)),
  [Symbol.for("get")]: (form, env) =>
    t.memberExpression(compile(form[1], env), compile(form[2], env), true),
}

// foo?.bar
const read = require("@blisp/reader/read")

// (console.log "foo")
const form = read('(call (. console log) "foo")')
console.log(form)

const compiled = compile(form, env)
console.log(compiled)

const js = generate(compiled)
console.log(js)
