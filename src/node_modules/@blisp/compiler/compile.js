const t = require("@babel/types")
const generate = require("@babel/generator").default

const quoted = Symbol("quoted")

class CallExpression extends Array {
  compile() {
    return t.callExpression(
      this[0].compile(),
      this.slice(1).map((param) => param.compile())
    )
  }
}

/**
 * '(get foo 'b)
 * -> [Symbol(quote) [Symbol(get) Symbol(foo) [Symbol(quote) Symbol(b)]]]
 * -> [Identifer(quote) [Symbol(get) Symbol(foo) [Symbol(quote) Symbol(b)]]]
 * -> [Symbol(get) Symbol(foo) [Symbol(quote) Symbol(b)]]
 * -> Object.assign(form.map(compile), { loc: , scopes })
 * -> [Object.assign(Symbol(get), { loc }), ]
 *
 * (get foo 'b)
 * -> [Symbol(get) Symbol(foo) [Symbol(quote) Symbol(b)]]
 * -> [(form) => new MemberExpression(...)]
 *
 *
 *  (get foo 'b)
 *    -> MemberExpression [
 *         Identifier("get"),
 *         Identifier("foo"),
 *         QuotedIdentifier("b")] -> foo.b
 *  (get foo b)
 *    -> MemberExpression [
 *         Identifier("get"),
 *         Identifier("foo"),
 *         Identifier("b")] -> foo[b]

 */
class MemberExpression extends Array {
  compile() {
    return t.memberExpression(
      this[1].compile(),
      isSymbol(this[2])
        ? t.identifier(Symbol.keyFor(this[2].valueOf()))
        : this[2].compile(),
      Array.isArray(this[2])
    )
  }
}

class Identifier {
  constructor(id) {
    this.id = id
  }
  valueOf() {
    return Symbol.for(this.id)
  }
  compile() {
    return t.identifier(this.id)
  }
}

class SymbolLiteral extends Symbol {
  compile() {
    return t.newExpression(t.identifier("SymbolLiteral"), [
      t.callExpression(
        t.memberExpression(t.identifier("Symbol"), t.identifier("for")),
        new ArrayExpression(Symbol.keyFor(this.valueOf()))
      ),
    ])
  }
}

class ArrayExpression extends Array {
  compile() {
    return t.arrayExpression(this.map((elem) => elem.compile()))
  }
}

class StringLiteral extends String {
  compile() {
    return t.stringLiteral(this.valueOf())
  }
}

function resolve(id, env) {
  if (typeof id.valueOf() === "symbol") {
    return env[id.valueOf()]
  }
  return undefined
}

function isSymbol(form) {
  return form instanceof Symbol || typeof form === "symbol"
}

function expand(form, env) {
  if (form.compile) {
    return form
  }
  if (Array.isArray(form)) {
    const first = expand(form[0], env)
    if (first && first.valueOf() === Symbol.for("quote")) {
      return form[1]
    }
    const macro = resolve(first, env)
    if (typeof macro === "function") {
      return expand(macro([first, ...form.slice(1)], env), env)
    }
    return new CallExpression(
      first,
      ...form.slice(1).map((subForm) => expand(subForm, env))
    )
  }
  if (form == null) {
    return form
  }
  switch (typeof form.valueOf()) {
    case "string":
      return new StringLiteral(form.valueOf())
    case "symbol":
      return new Identifier(Symbol.keyFor(form.valueOf()))
  }
  return form
}

function compile(form) {
  if (form.compile) {
    return form.compile()
  }
  if (Array.isArray(form)) {
    return t.ArrayExpression(form.map(compile))
  } else if (form === null) {
    return t.nullLiteral()
  } else if (form === undefined) {
    return t.identifier("undefined")
  }
  switch (typeof form.valueOf()) {
    case "string":
      return t.callExpression(
        t.memberExpression(t.identifier("Object"), t.identifier("assign")),
        [t.stringLiteral(form.valueOf())]
      )
    case "symbol":
      return t.callExpression(
        t.memberExpression(t.identifier("Object"), t.identifier("assign")),
        [
          t.callExpression(
            t.memberExpression(t.identifier("Symbol"), t.identifier("for")),
            [t.stringLiteral(Symbol.keyFor(form.valueOf()))]
          ),
        ]
      )
  }
}

const env = {
  [Symbol.for("get")]: (form, env) =>
    new MemberExpression(...form.map((subForm) => expand(subForm, env))),
  [Symbol.for("quote")]: (form, env) => form[1],
}

// ((get console 'log) "Hello World")
// console.log("Hello World")
const form = [
  [
    Symbol.for("get"),
    Symbol.for("console"),
    [Symbol.for("quote"), Symbol.for("log")],
  ],
  "Hello World",
]

function foo() {
  return "log"
}

console.log(form)

const expanded = expand([Symbol.for("quote"), form], env)
console.log(expanded)

const compiled = compile(expanded)
console.log(compiled)

const generated = generate(compiled)
console.log(generated)

const qform = eval(generated.code)

const qexpanded = expand(qform, env)
console.log(qexpanded)

const qcompiled = compile(qexpanded)
console.log(qcompiled)

const qgenerated = generate(qcompiled)
console.log(qgenerated)

eval(qgenerated.code)

module.exports = compile
