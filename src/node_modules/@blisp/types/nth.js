const { identifier } = require("@babel/types")
const env = require("@blisp/es5")

const reverseEnv = Object.values(env).reduce((reverseEnv, macro) => {
  if (macro.type) {
    reverseEnv[macro.type] = macro
  }
  return reverseEnv
}, {})

/**
 * ;;;; File Level  Comment
 * ;;; Variablre level comment
 * ;; Code documentation
 *
 * (function foo (bar) (return bar)) ; oeu
 */
module.exports = function nth(form, n) {
  if (Array.isArray(form)) {
    return form[n]
  }
  switch (form.type) {
    case "CommentLine":
    case "CommentBlock":
      switch (n) {
        case 0:
          identifier("comment")
        case 1:
          form.value
        default:
          undefined
      }

    case "ArrayExpression":
      return form.elements[n]

    case "BinaryExpression":
      switch (n) {
        case 0:
          return identifier(form.operator)
        case 1:
          return form.left
        case 2:
          return form.reight
      }

    // case InterpreterDirective:
    // case "Directive"
    // case "DirectiveLiteral"

    // (block ...stmts)
    case "BlockStatement":
      return n === 0 ? identifier("block") : form.body[n - 1]

    // (break label?)
    case "BreakStatement":
      return n === 0 ? identifier("break") : form.label || undefined

    // (foo bar)
    case "CallExpression":
      return n === 0 ? form.callee : form.arguments[n - 1]

    // (try (block (...)) (catch () (block ...)) (finally (block ...))
    case "CatchClause":
      switch (n) {
        case 0:
          return identifier("catch")
        case 1:
          return form.param
        case 2:
          return form.body
      }

    // (?: test consequent alternate)
    case "ConditionalExpression":
      switch (n) {
        case 0:
          return identifier("?:")
        case 1:
          return form.test
        case 2:
          return form.alternate
        default:
          return undefined
      }

    // (continue label?)
    case "ContinueStatement":
      switch (n) {
        case 0:
          return identifier("continue")
        case 1:
          return form.label || undefined
        default:
          return undefined
      }

    // (debugger)
    case "DebuggerStatement":
      return n === 0 ? identifier("debugger") : undefined

    // (dowhile test body)
    case "DoWhileStatement":
      switch (n) {
        case 0:
          return identifier("dowhile")
        case 1:
          return form.test
        case 2:
          return form.body
        default:
          return undefined
      }

    // (noop)
    case "EmptyStatement":
      return n === 0 ? identifier("noop") : undefined

    case "ExpressionStatement":
      return nth(form.expression)

    // case "File":

    case "ForInStatement":
      switch (n) {
        case 0:
          return identifier("forin")
        case 1:
          return form.left
        case 2:
          return form.right
        case 3:
          return form.body
        default:
          undefined
      }

    // (for (var i 0) (!= i 10) (++ i) stmt)
    // (for () () () stmt)
    case "ForStatement":
      switch (n) {
        case 0:
          return identifier("for")
        case 1:
          return form.init || []
        case 2:
          return form.test || []
        case 3:
          return form.update || []
        case 4:
          return form.body
      }

    /**
     * (function (bar baz) (return (bar baz)))
     * (function foo (bar baz) (return (bar baz)))
     * (function* foo (bar baz) (return (bar baz)))
     * (async function foo (bar baz) (return (bar baz)))
     * (async function* (bar baz) (return (bar baz)))
     * (async function* foo (bar baz) (return (bar baz)))
     */
    case "FunctionDeclaration":
    case "FunctionExpression":
      switch (n) {
        case 0:
          return form.async
            ? identifier("async")
            : form.generator
              ? identifier("function*")
              : identifier("function")
        case 1:
          form.async
            ? form.generator
              ? identifier("function*")
              : identifier("function")
            : form.id
              ? form.id
              : form.params
        case 2:
          form.async
            ? form.id
              ? form.id
              : form.params
            : form.id
              ? form.params
              : form.body
        case 3:
          form.async
            ? form.id
              ? form.params
              : form.body
            : form.id
              ? form.body
              : undefined // Should this be an ast node?
      }

    // case Identifier:

    // (if test consequent (if elseIfTest alternate))
    case "IfStatement":
      switch (n) {
        case 0:
          return identifier("if")
        case 1:
          return form.test
        case 2:
          return form.consequent
        case 3:
          return form.alternate
        default:
          return undefined
      }

    // (label stmt)
    case "LabeledStatement":
      switch (n) {
        case 0:
          return identifier("label")
        case 1:
          return form.statement
        default:
          return undefined
      }

    // TODO: throw exception?
    // cose StringLiteral:
    // cose NumericLiteral:
    // cose NullLiteral:
    // cose BooleanLiteral:
    // cose RegExpLiteral:

    // (|| foo bar)
    case "LogicalExpression":
      switch (n) {
        case 0:
          return identifier(form.operator)
        case 1:
          return form.left
        case 2:
          return form.right
        default:
          return undefined
      }

    // (. foo bar)
    // (get foo "bar")
    case "MemberExpression":
      switch (n) {
        case 0:
          return form.computed ? identifer("get") : identifer(".")
        case 1:
          return form.object
        case 2:
          return form.computed
        default:
          return undefined
      }

    // (new Foo bar baz)
    case "NewExpression":
      switch (n) {
        case 0:
          return identifier("new")
        case 1:
          return form.callee
        default:
          return form.arguments[n - 2]
      }

    // case "Program":

    /** {foo: bar
     *
     *   [foo]: bar
     *   foo
     *   bar
     *   ...foo
     *   (get [foo] [bar baz] (block (return (bar baz)))}
     */
    case "ObjectExpression":
      return form.properties[n]

    // (method foo [bar baz] (block (return (bar baz)))}
    // (async method foo [bar baz] body)
    // (async method* foo [bar baz] body)
    case "ObjectMethod":
      switch (n) {
        case 0:
          return identifier(`${form.kind}${form.generator ? "*" : ""}`)
        case 1:
          // TODO: Should computed actually be array expression?
          return form.computed ? [form.key] : form.key
        case 2:
          return form.params
        case 3:
          return form.body
      }

    // Not sure
    // case "ObjectProperty":

    // ...foo -> (rest foo)
    case "RestElement":
      switch (n) {
        case 0:
          return identifier("rest")
        case 1:
          return form.argument
        default:
          return undefined
      }

    // (return foo?)
    case "ReturnStatement":
      switch (n) {
        case 0:
          return identifier("return")
        case 1:
          return form.argument
        default:
          return undefined
      }

    // (sequence ...exprs)
    case "SequenceExpression":
      switch (n) {
        case 0:
          return identifier("sequence")
        default:
          return form.expressions[n - 1]
      }

    /**
     * (switch test
     *   (case testcase ...stmts)
     *   (default ...stmts))
     */
    case "SwitchCase":
      switch (n) {
        case 0:
          return form.test ? identifier("case") : identifier("default")
        case 1:
          return form.test ? form.test : form.consequent[0]
        default:
          return form.consequent[n - form.test ? 2 : 1]
      }

    // TODO: Literal do we throw?
    // case "ThisExpression":

    // (throw argument)
    case "ThrowStatement":
      switch (n) {
        case 0:
          return identifier("throw")
        case 1:
          return form.argument
        default:
          return undefined
      }

    // (try (block (...)) (catch () (block ...)) (finally (block ...))
    case "TryStatement":
      switch (n) {
        case 0:
          return identifier("try")
        case 1:
          return form.block
        case 2:
          return form.handler || form.finalizer
        case 3:
          return form.handler ? form.finalizer : undefined
        default:
          return undefined
      }

    // TODO: throw expression
    case "UnaryExpression":
      switch (n) {
        case 0:
          return identifier(form.operator)
        case 1:
          return form.argument
        default:
          return undefined
      }

    // (++ i) -> i++
    // (++_ i) -> ++i
    case "UpdateEpression":
      switch (n) {
        case 0:
          return identifier(`${form.operator}${form.prefix ? "_" : ""}`)
        case 1:
          return form.argument
        default:
          return undefined
      }

    // (define kind ...(id init))
    case "VariableDeclaration":
      switch (n) {
        case 0:
          return identifier("define")
        default:
          return form.declarations[n - 1]
      }

    case "VariableDeclarator":
      switch (n) {
        case 0:
          return form.id
        case 1:
          return form.init
      }

    // (while test body)
    case "WhileStatement":
      switch (n) {
        case 0:
          return identifier("while")
        case 1:
          return form.test
        case 2:
          return form.body
        default:
          undefined
      }

    // (with object body)
    case "WithStatement":
      switch (n) {
        case 0:
          return identifier("with")
        case 1:
          return form.object
        case 2:
          return form.body
        default:
          undefined
      }
  }
}
